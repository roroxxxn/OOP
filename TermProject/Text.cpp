#include "Text.h"
#include<vector>
#include<iostream>
#include<cmath>
#include<string>

using namespace std;

// 아직 객체가 생성되지 않았으므로 각각 false와 NULL로 초기화한다.
bool Text::instanceFlag = false;
Text* Text::m = NULL;

/*
 * 싱글턴 객체를 반환할 멤버함수
 * 아직 객체가 생성되지 않았으면 객체를 생성하여 리턴하고,
 * instanceFlag를 true로 변경한다.
 */
Text* Text::getInstance() {
	if (!m) { 
		m = new Text();
		instanceFlag = true;
	}
	return m;
}

/* 
 * 삽입 명령어를 실행하는 함수
 * <매개변수>
 * ir : 삽입할 행
 * ic : 삽입할 열
 * inserted : 삽입할 문자
 * j : 현재 페이지에서 맨 앞에 있는 단어의 인덱스 번호
 * <리턴 값>
 * 잘못된 인덱스 입력 시 0, 정상 입력 시 1을 리턴한다.
 */
int Text::insert(int ir, int ic, string inserted, int j) {

	if (ir > 20) {	// 한 페이지에 20행 까지 출력할 수 있으므로 20을 넘어가는 입력은 잘못된 입력이다.
		return 0;	// 잘못된 인덱스 입력 시 0을 리턴한다.
	}

	// 1) 인덱스 번호 알아내기
	int size = 0;	// 한 행의 사이즈를 검사하기 위한 변수
	int row = 1;	// 몇 개의 행을 검사하였는지 저장하는 변수

	while (1) {
		if (row == ir) {			// 입력한 행에 도달하면 while루프를 빠져나온다.
			break;
		}
		size += txt[j].size() + 1;	// 공백 한 칸의 길이와 단어 하나의 길이를 누적해서 더해준다.
		if (size > 75) {			// 한 행당 75바이트 까지 출력할 수 있으므로 size가 75를 넘어가면
			size = 0;				// size를 0으로 초기화하고
			j--;					// 검사하는 인덱스를 한 칸 뒤로 밀어주고
			row++;					// row를 1 증가시킨다.
		}
		j++;						// 반복할 때마다 단어의 인덱스를 앞으로 한 칸씩 전진시킨다.
	}
	
	// 2) 해당 열의 단어의 개수를 알아낸다.
	int size2 = 0;	// 한 열의 사이즈를 검사하기 위한 변수
	int cnt = 0;	// 단어의 개수를 저장할 변수
	int p = j;		// p는 행의 수를 계산한 후의 인덱스 번호이다.
	while (size2 < 75) {
		size2 += txt[p].size() + 1;	// 공백 한 칸의 길이와 단어 하나의 길이를 누적해서 더해준다.
		if (size > 75) {			// 한 행당 75바이트 까지 출력할 수 있으므로 size가 75를 넘어가면
			p--;					// 검사하는 인덱스를 한 칸 뒤로 밀어주고 루프를 빠져나온다.
			break;
		}
		p++;	// 반복할 때마다 단어의 인덱스를 앞으로 한 칸씩 전진시킨다.
		cnt++;	// 반복할 때마다 단어의 개수를 1 증가시킨다.
	}

	// 3) 삭제
	if (ic <= cnt - 1 && ic > 0) { // 입력한 열이 범위안에 있을 때 해당 열의 위치에 단어를 삽입한다.
		for (int k = 1; k < ic; k++) {
			j++;
		}
		txt.insert(txt.begin() + j + 1, inserted);
		return 1;
	}
	else { // 입력한 열이 범위를 벗어날 때 0을 리턴한다.
		return 0;
	}

};

/*
 * 삭제 명령어를 실행하는 함수
 * <매개변수>
 * r : 삭제할 단어의 행
 * c : 삭제할 단어의 열
 * j : 현재 페이지에서 맨 앞에 있는 단어의 인덱스 번호
 * <리턴 값>
 * 잘못된 인덱스 입력 시 0, 정상 입력 시 1을 리턴한다.
 */
int Text::del(int r, int c, int j) {

	if (r > 20) {	// 한 페이지에 20행 까지 출력할 수 있으므로 20을 넘어가는 입력은 잘못된 입력이다.
		return 0;	// 잘못된 인덱스 입력 시 0을 리턴한다.
	}

	// 1) 인덱스 번호 알아내기
	int size = 0;	// 한 행의 사이즈를 검사하기 위한 변수
	int row = 1;	// 몇 개의 행을 검사하였는지 저장하는 변수

	while (1) {
		if (row == r) {				// 입력한 행에 도달하면 while루프를 빠져나온다.
			break;
		}
		size += txt[j].size() + 1;	// 공백 한 칸의 길이와 단어 하나의 길이를 누적해서 더해준다.
		if (size > 75) {			// 한 행당 75바이트 까지 출력할 수 있으므로 size가 75를 넘어가면
			size = 0;				// size를 0으로 초기화하고
			j--;					// 검사하는 인덱스를 한 칸 뒤로 밀어주고
			row++;					// row를 1 증가시킨다.
		}
		j++;						// 반복할 때마다 단어의 인덱스를 앞으로 한 칸씩 전진시킨다.
	}

	// 2) 해당 열의 단어의 개수를 알아낸다.
	int size2 = 0;	// 한 열의 사이즈를 검사하기 위한 변수
	int cnt = 0;	// 단어의 개수를 저장할 변수
	int p = j;		// p는 행의 수를 계산한 후의 인덱스 번호이다.
	while (size2 < 75) {
		size2 += txt[p].size() + 1;	// 공백 한 칸의 길이와 단어 하나의 길이를 누적해서 더해준다.
		if (size > 75) {			// 한 행당 75바이트 까지 출력할 수 있으므로 size가 75를 넘어가면
			p--;					// 검사하는 인덱스를 한 칸 뒤로 밀어주고 루프를 빠져나온다.
			break;
		}
		p++;	// 반복할 때마다 단어의 인덱스를 앞으로 한 칸씩 전진시킨다.
		cnt++;	// 반복할 때마다 단어의 개수를 1 증가시킨다.
	}

	// 3) 삭제
	if (c <= cnt - 1 && c > 0) {		// 입력한 열이 범위안에 있을 때 해당 열의 단어를 삭제한다.
		for (int k = 1; k < c; k++) {
			j++;
		}
		txt.erase(txt.begin() + j);
		return 1;
	}
	else {								// 입력한 열이 범위를 벗어날 때 0을 리턴한다.
		return 0;
	}
};

/*
 * 변경 명령어를 실행하는 함수
 * <매개변수>
 * from : 변경되어야하는 단어
 * to : 대체되는 단어
 */
void Text::change(string from, string to) {
	for (int i = 0; i < txt.size(); i++) {	// 텍스트 내의 모든 단어를 순회하면서
		if (from == txt[i]) {				// 변경해야 할 단어를 찾으면
			txt.erase(txt.begin() + i);		// 해당 단어를 지우고 (i=4, 5번째 원소)
			txt.insert(txt.begin() + i, to);// 동일한 위치에 대체할 단어를 삽입한다.
		}
	}
};

/*
 * 탐색 명령어를 실행하는 함수
 * <매개변수>
 * sch : 탐색하고자 하는 단어
 * <리턴 값>
 * 출력해야하는 첫 번째 인덱스
 */
int Text::search(string sch) { // j =  프린트해야하는 인덱스
	// 탐색하는 단어가 페이지의 맨 처음에 출력되는 것이 아니라 첫번째 행에 나타나도록 출력하는 것이다.
	// 따라서 행이 바뀔 때 마다 리턴할 인덱스 값은 현재 행의 첫번째가 되도록 한다.

	int j = 0;		// 리턴 값을 저장할 변수
	int size = 0;	// 한 행의 사이즈를 검사하기 위한 변수
	int ret = 0;	// 현재 행의 첫번째 인덱스

	for (int i = 0; i < txt.size(); i++) {	// 텍스트의 모든 단어를 순회한다.
		size += txt[i].size() + 1;			// 공백 한 칸의 길이와 단어 하나의 길이를 누적해서 더해준다.
		if (size > 75) {					// 한 행당 75바이트 까지 출력할 수 있으므로 size가 75를 넘어가면
			size = 0;						// size를 0으로 초기화하고
			ret = i;						// 현재 행의 첫번째 인덱스는 i가 된다.
			i--;							// 검사해야하는 단어의 인덱스를 다시 앞으로 한 칸 밀어준다.
			continue;						// 아래의 코드를 실행하지 않고 다음 단어에 대한 검사를 진행한다.
		}
		if (sch == txt[i]) {	// 탐색하고자 하는 단어를 찾으면
			j = ret;			// 현재 행의 첫번째 인덱스를 리턴하도록 하고
			break;				// 탐색을 끝낸다.
		}
	}
	return j; // 출력해야하는 첫번째 인덱스
};

/*
 * 텍스트 출력을 위한 함수
 * <매개변수>
 * j : 현재 프린트할 벡터의 인덱스 번호
 * vs : 전체 텍스트의 길이
 * <리턴 값>
 * 현재 페이지 다음(n)에 출력해야 할 첫번 째 단어의 인덱스 번호
 */
int Text::textprint(int j, int vs) {
	// 한 페이지 당 20행을 출력한다.
	for (int i = 0; i < 20; i++) { 
		if (i < 9) {
			cout << " " << i + 1 << "| ";
		}
		else {
			cout << i + 1 << "| ";
		}

		// 한 행 당 공백을 포함하여 75바이트까지 출력가능하다.
		int size = 0;					// 한 행의 사이즈를 검사하기 위한 변수
		while (1) {
			size += txt[j].size() + 1;	// 공백 한 칸의 길이와 단어 하나의 길이를 누적해서 더해준다.

			if (size > 75) {			// 한 행당 75바이트 까지 출력할 수 있으므로 size가 75를 넘어가면
				break;					//다음 행을 출력한다.
			}

			cout << txt[j] + " ";		// 인덱스 값을 출력하고
			j++;						// 다음 단어를 출력하기 위해 인덱스 번호를 1 증가시킨다.

			if (j == vs) {				// 만약 증가시킨 인덱스가 텍스트의 길이와 같으면 더 이상 출력할 텍스트가 없으므로
				goto EXIT;				// while루프를 빠져나온다.
			}
		}

		cout << "\n";
	}
EXIT:
	cout << "\n";
	return j; // j는 현재 페이지 다음(n)에 출력해야 할 첫번 째 단어의 인덱스 번호가 된다.
};

/*
 * 텍스트 내용을 set하는 함수
 * <매개변수>
 * k : 텍스트 파일에서 입력받은 문자열 vector
 */
void Text::setter(vector<string>& k) {
	for (int i = 0; i < k.size(); i++) {
		txt.push_back(k[i]); // 매개변수로 전달받은 vector의 내용을 순서대로 txt에 삽입한다.
	}
};

/*
 * 현재 창에 출력된 텍스트의 앞에 남아있는 행의 수
 * <매개변수>
 * j : 현재 페이지에서 맨 앞에 있는 단어의 인덱스 번호
 * <리턴 값>
 * 인덱스 j의 단어 앞에 남아있는 행의 수
 */
int Text::fremainder(int j) {
	// 현재 창에 출력된 텍스트의 앞에 남아있는 행의 수를 구하기 위해
	// 이전페이지의 마지막 단어부터 첫번 째 단어까지 반복하여 행이 몇 번 누적되는지 체크한다.

	int size = 0;	// 한 행의 사이즈를 검사하기 위한 변수
	int p = j - 1;	// p는 현재 페이지에서 맨 앞에 있는 단어의 인덱스 번호에서 1을 뺀 값이다.
	int row = 0;	// 몇 개의 행이 남아있는지 체크하는 변수

	while (p >= 0) {				// 인덱스 p부터 시작하여 첫번 째 인덱스까지 반복한다.
		size += txt[p].size() + 1;	// 공백 한 칸의 길이와 단어 하나의 길이를 누적해서 더해준다.
		if (size > 75) {			// 한 행당 75바이트 까지 출력할 수 있으므로 size가 75를 넘어가면
			size = 0;				// size를 0으로 초기화하고
			row++;					// row를 1 증가시키고
			p++;					// 검사하는 단어의 인덱스는 다시 한 칸 뒤로 밀려나게 된다.

		}
		p--;	// 반복할 때마다 단어의 인덱스를 앞으로 한 칸씩 전진시킨다.

	}
	return row;	// 누적된 행의 수를 리턴한다.
}

/*
 * 현재 창에 출력된 텍스트의 뒤에 남아있는 행의 수
 * <매개변수>
 * count : 현재 페이지 다음(n)에 출력해야 할 첫번 째 단어의 인덱스 번호
 * vs : 전체 텍스트의 길이
 * <리턴 값>
 * 인덱스 count의 단어를 포함하여 인덱스 count 단어 뒤에 남아있는 행의 수
 */
int Text::bremainder(int count, int vs) { 
	// 현재 창에 출력된 텍스트의 뒤에 남아있는 행의 수를 구하기 위해
	// 다음페이지의 맨 앞 단어부터 시작하여 마지막 단어까지 반복하여 행이 몇 번 누적되는지 체크한다.

	int size = 0;	// 한 행의 사이즈를 검사하기 위한 변수
	int p = count;	// p는 현재 페이지 다음(n)에 출력해야 할 첫번 째 단어의 인덱스 번호이다.
	int row = 1;	// 몇 개의 행이 남아있는지 체크하는 변수

	while (p < vs) {				// 인덱스 p부터 마지막 인덱스까지 반복한다.
		size += txt[p].size() + 1;	// 공백 한 칸의 길이와 단어 하나의 길이를 누적해서 더해준다.
		if (size > 75) {			// 한 행당 75바이트 까지 출력할 수 있으므로 size가 75를 넘어가면
			size = 0;				// size를 0으로 초기화하고
			row++;					// row를 1 증가시키고
			p--;					// 검사하는 단어의 인덱스는 다시 한 칸 앞으로 밀려난다.
		}
		p++;	// 반복할 때마다 단어의 인덱스를 뒤로 한 칸씩 밀어준다.
	}
	return row; // 누적된 행의 수를 리턴한다.
}

/*
 * 전체 텍스트 중에서 i번째 인덱스의 값을 리턴하는 함수
 */
string Text::at(int i) { 
	return txt[i]; // txt의 i번째 인덱스 값을 리턴한다.
}